Introduction to Heap 
--------------------

1. Why use heap ? 

For Memory allocation in runtime. If data in a variable is needed beyond the lifetime of a current function. When you do not know how much memory space is required (a user may open any no. of tabs in his browser, its hard to predetermine this). kernel does this using syscalls suck as brk(), mmap(), sbrk() but not as intricate as malloc()

2. How does it work ? 

User requests memory allocation through functions. Memory is freed by user / garbage collection / program terminattion. Failure to free the memory space can lead to memory leakage, resource exhaustion, fragmentation. High to low memory. Using malloc() which is interface to realloc(), calloc(), free() 

malloc() - allocate memory 
calloc() - allocate memory while initializing it to zero 
free ()  - free :) 
realloc() - modify size of existing chunk 

Chunk in memory when allocated using malloc() 



Allocated Chunk : 
 _________________________
|       Prev Size         | Chunk Pointer (size of previous chuck, used to determine if previous chunk is empty or not)
|_________________________| 
 _________________________
|       Size              |
|_________________________|
 _________________________
|       Data              |
|_________________________|


Freed Chunk : 
 _________________________
|       Prev Size         | Chunk Pointer (size of previous chuck, used to determine if previous chunk is empty or not)
|_________________________| 
 _________________________
|       Size              |
|_________________________|
 _________________________
|       fwd bck pointer   |
|_________________________|
 _________________________
|       Data              |
|_________________________|


Bins : 

Chunks are stored in bins, chucks greater than 128Kbs are not stored in bins but my mmap(). Frontlink() worls with an index to determine appropriate bin for freed chunk. 

Fast bins are dangerous, as they prefer efficiency over security. Chunks from middle are not taken ,LIFO is used. 

3. Heap Attacks 

Two Main Objectives : 
----------------------
1. Overwrite Heap Meta Data - FWD/BWD pointers, heap header to create new arenas 
2. Overwrite App Function Pointers - Unitialized pointers in BSS segment(GOT, .dtors), app data residing within chunk allocation
