Introduction to Heap 
--------------------

1. Why use heap ? 
For Memory allocation in runtime. If data in a variable is needed beyond the lifetime of a current function. When you do not know how much memory space is required (a user may open any no. of tabs in his browser, its hard to predetermine this). kernel does this using syscalls suck as brk(), mmap(), sbrk() but not as intricate as malloc()

2. How does it work ? 
User requests memory allocation through functions. Memory is freed by user / garbage collection / program terminattion. Failure to free the memory space can lead to memory leakage, resource exhaustion, fragmentation. High to low memory. Using malloc() which is interface to realloc(), calloc(), free() 

malloc() - allocate memory 
calloc() - allocate memory while initializing it to zero 
free ()  - free :) 
realloc() - modify size of existing chunk 

Chunk in memory when allocated using malloc() 

Allocated Chunk : 
 _________________________
|       Prev Size         | Chunk Pointer (size of previous chuck, used to determine if previous chunk is empty or not)
|_________________________| 
 _________________________
|       Size              |
|_________________________|
 _________________________
|       Data              |
|_________________________|


Freed Chunk : 
 _________________________
|       Prev Size         | Chunk Pointer (size of previous chuck, used to determine if previous chunk is empty or not)
|_________________________| 
 _________________________
|       Size              |
|_________________________|
 _________________________
|       fwd bck pointer   |
|_________________________|
 _________________________
|       Data              |
|_________________________|


Bins : 

Chunks are stored in bins, chucks greater than 128Kbs are not stored in bins but my mmap(). Frontlink() worls with an index to determine appropriate bin for freed chunk. 
Fast bins are dangerous, as they prefer efficiency over security. Chunks from middle are not taken ,LIFO is used. 

3. Heap Attacks 

Two Main Objectives : 
----------------------
1. Overwrite Heap Meta Data - FWD/BWD pointers, heap header to create new arenas 
2. Overwrite App Function Pointers - Unitialized pointers in BSS segment(GOT, .dtors), app data residing within chunk allocation


one of most dealdliest attacks in use after free attacks which is also called as abusing unlink macro in free() function call. What happens is that an attacker, who is able able to write arbitary data to a chunk and overflow an adjacent chunk can make the adjacent chunk look like it is already free as a result the unlink macro performs collision and attempts to combine the chunk and the chunk the fwd pointer points to, as the attacker has control over this pointer, he/she can make the chunk point to any address in writeable and redirect execution flow to that address. 

by now the impact would be well understood, the adversary can write to any arbitary location and redirect program execution flow and as a result run their own shell code, this is mainly achieved by replacing memory addresses in the .GOT section. 
