Format String Vulnerability
---------------------------

A vulnerability that is very easy to identify but complicated to exploit. Just like our UAF bug using this vulnerability we can write to any writeable location, 
as well as execute our own shell code. 

Lets take a vulnerable program : 
---------------------------------
#include <stdlib.h>
#include <stdio.h>
#include <string.h> 

int main(int argc, char *argv[]) {

char buffer[64]; 
static int value =25; 

if argc !=2)
return -1; 

strcpy(buffer,argv[1]); 
printf("\n with FI you entered: %s\n", buffer);
printf("\n without FI you entered: ", buffer);
printf(buffer); 

printf("\n\n5*5 = %d. The address of this variable is 0x%08x. In hex thats 0x%08x.\n\n", value, &value, value);
exit(0);
}

The function primarily responsible for this is printf() in the line  [ printf("\n without FI you entered: ", buffer); ], as there is no restriction in the type of data to be displayed the adversary can use this to his/her and read instruction / data from any location of his choice.  Not just this, as the strcpy() function does no bounds check an adversary can write to any writeable memory address, in this case we can replace the value of the variable 'value' from 25 to any value of our choice with the following payload. 


./vuln_pgm `python -c 'print "<address of the variable>"'` %x%x%x%X%X%X%X (arguements till you reach the one you control,%<any new value>x,%n

The pre-requisite in order to exploit this smoothly would be to precisley identify the arguement that you have full control over. Example the user input may be : 
aaaa.%x.%x.%x.%x.%x 

the output could be 

6474645,6353637,8474747,0,41414141 

41414141 = aaaa, this means that you control the 5th aruguement. USing this vulnerability and with the help of overflows such as strcpy() you could run your own shellcode.





